namespace Skew {
  enum PassKind {
    PARSING
  }

  class ParsingPass : Pass {
    over kind PassKind {
      return .PARSING
    }

    over run(context PassContext) {
      for tokens in context.tokens {
        Parsing.parseFile(context.log, tokens, context.global)
      }
    }
  }
}

namespace Skew.Parsing {
  var expressionParser Pratt
  var typeParser Pratt

  # Parser recovery is done by skipping to the next closing token after an error
  def scanForToken(context ParserContext, kind TokenKind) {
    if context.expect(kind) {
      return
    }

    # Scan forward for the token
    while !context.peek(.END_OF_FILE) {
      if context.eat(kind) {
        return
      }

      switch context.current.kind {
        # Stop at the next closing token
        case .RIGHT_PARENTHESIS, .RIGHT_BRACKET, .RIGHT_BRACE {
          return
        }

        # Optionally recover parsing before the next statement if it's unambiguous
        case .BREAK, .CATCH, .CONST, .CONTINUE, .ELSE, .FINALLY, .FOR, .IF, .RETURN, .TRY, .VAR, .WHILE {
          return
        }
      }

      context.next
    }
  }

  def parseIntLiteral(log Log, range Range) Box<int> {
    var text = range.toString
    var isNegative = text.startsWith("-") # Parse negative signs for use with the "--define" flag
    var start = isNegative as int
    var count = text.count
    var value = 0
    var base = 10

    # Parse the base
    if start + 2 < count && text[start] == '0' {
      var c = text[start + 1]
      if c == 'b' {
        base = 2
        start += 2
      } else if c == 'o' {
        base = 8
        start += 2
      } else if c == 'x' {
        base = 16
        start += 2
      }
    }

    # There must be numbers after the base
    if start == count {
      return null
    }

    # Special-case hexadecimal since it's more complex
    if base == 16 {
      for i in start..text.count {
        var c = text[i]
        if (c < '0' || c > '9') && (c < 'A' || c > 'F') && (c < 'a' || c > 'f') {
          return null
        }
        value = value * 16 + c - (c <= '9' ? '0' : c <= 'F' ? 'A' - 10 : 'a' - 10)
      }
    }

    # All other bases are zero-relative
    else {
      for i in start..text.count {
        var c = text[i]
        if c < '0' || c >= '0' + base {
          return null
        }
        value = value * base + c - '0'
      }
    }

    # Warn about decimal integers that start with "0" because other languages
    # strangely treat these numbers as octal instead of decimal
    if base == 10 && value != 0 && text[0] == '0' {
      log.syntaxWarningOctal(range)
    }

    return Box<int>.new(isNegative ? -value : value)
  }

  def checkExtraParentheses(context ParserContext, node Node) {
    if node.isInsideParentheses {
      context.log.semanticWarningExtraParentheses(node.range)
    }
  }

  def parseLeadingComments(context ParserContext) List<string> {
    var comments List<string> = null
    while context.peek(.COMMENT) {
      var range = context.next.range
      comments ?= []
      comments.append(range.source.contents.slice(range.start + 1, range.end))

      # Ignore blocks of comments with extra lines afterward
      if context.eat(.NEWLINE) {
        comments = null
      }
    }
    return comments
  }

  def parseTrailingComment(context ParserContext, comments List<string>) List<string> {
    if !context.peek(.COMMENT) {
      return null
    }
    var range = context.next.range
    comments ?= []
    var text = range.source.contents.slice(range.start + 1, range.end)
    if !text.endsWith("\n") {
      text += "\n"
    }
    comments.append(text)
    return comments
  }

  def parseAnnotations(context ParserContext, annotations List<Node>) List<Node> {
    while context.peek(.ANNOTATION) {
      var range = context.next.range
      var value = Node.createName(range.toString).withRange(range)

      # Change "@foo.bar.baz" into "foo.bar.@baz"
      if context.peek(.DOT) {
        var root = value.asString
        value.content = StringContent.new(root.slice(1))
        while context.eat(.DOT) {
          var name = context.current.range
          if !context.expect(.IDENTIFIER) {
            break
          }
          value = Node.createDot(value, name.toString).withRange(context.spanSince(range)).withInternalRange(name)
        }
        value.content = StringContent.new("@" + value.asString)
      }

      # Parse parentheses if present
      var token = context.current
      if context.eat(.LEFT_PARENTHESIS) {
        var call = Node.createCall(value)
        parseArgumentList(context, call, .RIGHT_PARENTHESIS)
        value = call.withRange(context.spanSince(range)).withInternalRange(context.spanSince(token.range))
      }

      # Parse a trailing if condition
      var test Node = null
      if context.eat(.IF) {
        test = expressionParser.parse(context, .LOWEST)
      }

      # All annotations must end in a newline to avoid confusion with the trailing if
      if !context.peek(.LEFT_BRACE) && !context.expect(.NEWLINE) {
        scanForToken(context, .NEWLINE)
      }

      annotations.append(Node.createAnnotation(value, test).withRange(context.spanSince(range)))
    }

    return annotations
  }

  def parseVarOrConst(context ParserContext) Node {
    var variables = Node.createVariables
    var token = context.next

    while true {
      var range = context.current.range

      if !context.expect(.IDENTIFIER) {
        return null
      }

      var symbol = VariableSymbol.new(.VARIABLE_LOCAL, range.toString)
      symbol.range = range

      if token.kind == .CONST {
        symbol.flags |= .IS_CONST
      }

      if peekType(context) {
        symbol.type = parseType(context)
      }

      if context.eat(.ASSIGN) {
        symbol.value = expressionParser.parse(context, .LOWEST)
      }

      variables.appendChild(Node.createVariable(symbol).withRange(context.spanSince(range)))

      if !context.eat(.COMMA) {
        break
      }
    }

    return variables.withRange(context.spanSince(token.range))
  }

  def parseJump(context ParserContext) Node {
    var token = context.next
    return (token.kind == .BREAK ? Node.createBreak : Node.createContinue).withRange(token.range)
  }

  def parseReturn(context ParserContext) Node {
    var token = context.next
    var value Node = null
    if !context.peek(.NEWLINE) && !context.peek(.COMMENT) && !context.peek(.RIGHT_BRACE) {
      value = expressionParser.parse(context, .LOWEST)
      checkExtraParentheses(context, value)
    }
    return Node.createReturn(value).withRange(context.spanSince(token.range))
  }

  def parseSwitch(context ParserContext) Node {
    var token = context.next
    var value = expressionParser.parse(context, .LOWEST)
    checkExtraParentheses(context, value)
    var node = Node.createSwitch(value)

    context.skipWhitespace
    if !context.expect(.LEFT_BRACE) {
      return null
    }

    context.eat(.NEWLINE)
    while !context.peek(.RIGHT_BRACE) {
      var comments = parseLeadingComments(context)

      # Ignore trailing comments
      if context.peek(.RIGHT_BRACE) || context.peek(.END_OF_FILE) {
        break
      }

      # Parse a new case
      var child = Node.createCase
      var start = context.current
      if context.eat(.CASE) {
        while true {
          var constant = expressionParser.parse(context, .LOWEST)
          checkExtraParentheses(context, constant)
          child.appendChild(constant)
          if !context.eat(.COMMA) {
            break
          }
        }
      }

      # Default cases have no values
      else if !context.eat(.DEFAULT) {
        context.expect(.CASE)
        return null
      }

      # Use a block instead of requiring "break" at the end
      var block = parseBlock(context)
      if block == null {
        return null
      }

      # Create the case
      child.comments = comments
      node.appendChild(child.appendChild(block).withRange(context.spanSince(start.range)))

      # Parse trailing comments and/or newline
      comments = parseTrailingComment(context, comments)
      if comments != null {
        child.comments = comments
        context.eat(.NEWLINE)
      } else if context.peek(.RIGHT_BRACE) || !context.expect(.NEWLINE) {
        break
      }
    }

    if !context.expect(.RIGHT_BRACE) {
      return null
    }

    return node.withRange(context.spanSince(token.range))
  }

  def parseFor(context ParserContext) Node {
    var token = context.next
    var range = context.current.range

    if !context.expect(.IDENTIFIER) {
      return null
    }

    # for a in b {}
    if context.eat(.IN) {
      var symbol = VariableSymbol.new(.VARIABLE_LOCAL, range.toString)
      symbol.range = range

      var value = expressionParser.parse(context, .LOWEST)

      if context.eat(.DOT_DOT) {
        var second = expressionParser.parse(context, .LOWEST)
        value = Node.createPair(value, second).withRange(Range.span(value.range, second.range))
      }
      checkExtraParentheses(context, value)

      var block = parseBlock(context)
      if block == null {
        return null
      }

      return Node.createForeach(symbol, value, block).withRange(context.spanSince(token.range))
    }

    # for a = 0; a < 10; a++ {}
    var setup = Node.createVariables
    context.undo

    while true {
      var nameRange = context.current.range

      if !context.expect(.IDENTIFIER) {
        return null
      }

      var symbol = VariableSymbol.new(.VARIABLE_LOCAL, nameRange.toString)
      symbol.range = nameRange

      if peekType(context) {
        symbol.type = parseType(context)
      }

      if context.eat(.ASSIGN) {
        symbol.value = expressionParser.parse(context, .LOWEST)
        checkExtraParentheses(context, symbol.value)
      }

      setup.appendChild(Node.createVariable(symbol).withRange(context.spanSince(nameRange)))

      if !context.eat(.COMMA) {
        break
      }
    }
    setup.range = context.spanSince(range)

    if !context.expect(.SEMICOLON) {
      return null
    }

    var test = expressionParser.parse(context, .LOWEST)

    if !context.expect(.SEMICOLON) {
      return null
    }

    var update = expressionParser.parse(context, .LOWEST)

    # This is the one place in the grammar that sequence expressions are allowed
    if context.eat(.COMMA) {
      update = Node.createSequence.appendChild(update)
      while true {
        var value = expressionParser.parse(context, .LOWEST)
        update.appendChild(value)
        if !context.eat(.COMMA) {
          break
        }
      }
    }

    var block = parseBlock(context)
    if block == null {
      return null
    }

    return Node.createFor(setup, test, update, block).withRange(context.spanSince(token.range))
  }

  def parseIf(context ParserContext) Node {
    var token = context.next
    var test = expressionParser.parse(context, .LOWEST)
    checkExtraParentheses(context, test)

    var trueBlock = parseBlock(context)
    if trueBlock == null {
      return null
    }

    return Node.createIf(test, trueBlock, null).withRange(context.spanSince(token.range))
  }

  def parseThrow(context ParserContext) Node {
    var token = context.next
    var value = expressionParser.parse(context, .LOWEST)
    checkExtraParentheses(context, value)
    return Node.createThrow(value).withRange(context.spanSince(token.range))
  }

  def parseTry(context ParserContext) Node {
    var token = context.next
    var tryBlock = parseBlock(context)
    if tryBlock == null {
      return null
    }
    return Node.createTry(tryBlock).withRange(context.spanSince(token.range))
  }

  def parseWhile(context ParserContext) Node {
    var token = context.next
    var test = expressionParser.parse(context, .LOWEST)
    checkExtraParentheses(context, test)

    var block = parseBlock(context)
    if block == null {
      return null
    }

    return Node.createWhile(test, block).withRange(context.spanSince(token.range))
  }

  def parseStatement(context ParserContext) Node {
    var token = context.current

    switch token.kind {
      case .BREAK, .CONTINUE { return parseJump(context) }
      case .CONST, .VAR { return parseVarOrConst(context) }
      case .FOR { return parseFor(context) }
      case .IF { return parseIf(context) }
      case .RETURN { return parseReturn(context) }
      case .SWITCH { return parseSwitch(context) }
      case .THROW { return parseThrow(context) }
      case .TRY { return parseTry(context) }
      case .WHILE { return parseWhile(context) }
    }

    var value = expressionParser.parse(context, .LOWEST)
    checkExtraParentheses(context, value)

    # A special case for better errors when users try to use C-style variable declarations
    if !value.isInsideParentheses && looksLikeType(value) && context.peek(.IDENTIFIER) && context.canReportSyntaxError {
      context.log.syntaxErrorVariableDeclarationNeedsVar(context.current.range)
    }

    var node = Node.createExpression(value).withRange(value.range)
    return node
  }

  def looksLikeType(node Node) bool {
    var kind = node.kind
    return
      kind == .NAME ||
      kind == .TYPE ||
      kind == .LAMBDA_TYPE ||
      kind == .DOT && node.dotTarget != null && looksLikeType(node.dotTarget) ||
      kind == .PARAMETERIZE && looksLikeType(node.parameterizeValue)
  }

  def parseStatements(context ParserContext, parent Node) bool {
    var previous Node = null
    context.eat(.NEWLINE)

    while !context.peek(.RIGHT_BRACE) && !context.peek(.XML_START_CLOSE) {
      var comments = parseLeadingComments(context)

      # Ignore trailing comments
      if context.peek(.RIGHT_BRACE) || context.peek(.XML_START_CLOSE) || context.peek(.END_OF_FILE) {
        break
      }

      # Merge "else" statements with the previous "if"
      if context.peek(.ELSE) {
        var isValid = previous != null && previous.kind == .IF && previous.ifFalse == null
        if !isValid {
          context.unexpectedToken
        }
        context.next

        # Match "else if"
        if context.peek(.IF) {
          var statement = parseIf(context)
          if statement == null {
            return false
          }

          # Append to the if statement
          var falseBlock = Node.createBlock.withRange(statement.range).appendChild(statement)
          falseBlock.comments = comments
          if isValid {
            previous.appendChild(falseBlock)
            previous = statement
          } else {
            previous = null
          }
        }

        # Match "else"
        else {
          var falseBlock = parseBlock(context)
          if falseBlock == null {
            return false
          }

          # Append to the if statement
          falseBlock.comments = comments
          if isValid {
            previous.appendChild(falseBlock)
            previous = falseBlock
          } else {
            previous = null
          }
        }
      }

      # Merge "catch" statements with the previous "try"
      else if context.peek(.CATCH) {
        var isValid = previous != null && previous.kind == .TRY && previous.finallyBlock == null
        if !isValid {
          context.unexpectedToken
        }
        var catchToken = context.next
        var symbol VariableSymbol = null
        var nameRange = context.current.range

        # Optional typed variable
        if context.eat(.IDENTIFIER) {
          symbol = VariableSymbol.new(.VARIABLE_LOCAL, nameRange.toString)
          symbol.range = nameRange
          symbol.type = parseType(context)
        }

        # Parse the block
        var catchBlock = parseBlock(context)
        if catchBlock == null {
          return false
        }

        # Append to the try statement
        var child = Node.createCatch(symbol, catchBlock).withRange(context.spanSince(catchToken.range))
        child.comments = comments
        if isValid {
          previous.appendChild(child)
        } else {
          previous = null
        }
      }

      # Merge "finally" statements with the previous "try"
      else if context.peek(.FINALLY) {
        var isValid = previous != null && previous.kind == .TRY && previous.finallyBlock == null
        if !isValid {
          context.unexpectedToken
        }
        context.next

        # Parse the block
        var finallyBlock = parseBlock(context)
        if finallyBlock == null {
          return false
        }

        # Append to the try statement
        finallyBlock.comments = comments
        if isValid {
          previous.appendChild(finallyBlock)
        } else {
          previous = null
        }
      }

      # Parse a new statement
      else {
        var current = context.current
        var statement = parseStatement(context)
        if statement == null {
          scanForToken(context, .NEWLINE)
          continue
        }

        # Prevent an infinite loop due to a syntax error at the start of an expression
        if context.current == current {
          context.next
        }

        # There is a well-known bug in JavaScript where a return statement
        # followed by a newline and a value is parsed as two statements,
        # a return statement without a value and an expression statement.
        # This is dumb so don't do this. Parse this as a single return
        # statement with a value instead.
        if previous != null && previous.kind == .RETURN && previous.returnValue == null && statement.kind == .EXPRESSION {
          previous.appendChild(statement.expressionValue.remove)
        }

        else {
          previous = statement
          statement.comments = comments
          parent.appendChild(statement)
        }
      }

      # Parse trailing comments and/or newline
      comments = parseTrailingComment(context, comments)
      if comments != null {
        if previous != null {
          previous.comments = comments
        }
        context.eat(.NEWLINE)
      } else if context.peek(.RIGHT_BRACE) || context.peek(.XML_START_CLOSE) {
        break
      } else if !context.peek(.ELSE) && !context.peek(.CATCH) && !context.peek(.FINALLY) {
        context.expect(.NEWLINE)
      }
    }

    return true
  }

  def parseBlock(context ParserContext) Node {
    context.skipWhitespace
    var token = context.current
    if !context.expect(.LEFT_BRACE) {
      return null
    }
    var block = Node.createBlock
    if !parseStatements(context, block) || !context.expect(.RIGHT_BRACE) {
      return null
    }
    return block.withRange(context.spanSince(token.range))
  }

  def parseType(context ParserContext) Node {
    return typeParser.parse(context, .LOWEST)
  }

  def peekType(context ParserContext) bool {
    return context.peek(.IDENTIFIER) || context.peek(.DYNAMIC)
  }

  def parseFunctionBlock(context ParserContext, symbol FunctionSymbol) bool {
    # "=> x" is the same as "{ return x }"
    if symbol.kind == .FUNCTION_LOCAL {
      if !context.expect(.ARROW) {
        return false
      }
      if context.peek(.LEFT_BRACE) {
        symbol.block = parseBlock(context)
        if symbol.block == null {
          return false
        }
      } else {
        var value = expressionParser.parse(context, .LOWEST)
        symbol.block = Node.createBlock.withRange(value.range).appendChild(Node.createReturn(value).withRange(value.range).withFlags(.IS_IMPLICIT_RETURN))
      }
    }

    # Parse function body if present
    else if context.peek(.LEFT_BRACE) {
      symbol.block = parseBlock(context)
      if symbol.block == null {
        return false
      }
    }

    return true
  }

  def parseFunctionArguments(context ParserContext, symbol FunctionSymbol) bool {
    var usingTypes = false
    var hasNamedArguments = false

    while !context.eat(.RIGHT_PARENTHESIS) {
      if !symbol.arguments.isEmpty && !context.expect(.COMMA) {
        return false
      }

      context.skipWhitespace

      var range = context.current.range
      if !context.expect(.IDENTIFIER) {
        return false
      }

      var arg = VariableSymbol.new(.VARIABLE_ARGUMENT, range.toString)
      arg.range = range

      # Parse named flag
      if symbol.kind != .FUNCTION_LOCAL && context.eat(.COLON) {
        arg.flags |= .IS_NAMED
        hasNamedArguments = true
      } else if hasNamedArguments {
        context.log.syntaxErrorUnnamedArgument(range)
      }

      # Parse argument type
      if symbol.kind != .FUNCTION_LOCAL || (symbol.arguments.isEmpty ? peekType(context) : usingTypes) {
        arg.type = parseType(context)
        usingTypes = true
      }

      # Optional arguments aren't supported yet
      var assign = context.current.range
      if context.eat(.ASSIGN) {
        expressionParser.parse(context, .LOWEST)
        context.log.syntaxErrorOptionalArgument(context.spanSince(assign))
      }

      symbol.arguments.append(arg)
    }

    return true
  }

  def parseFunctionReturnTypeAndBlock(context ParserContext, symbol FunctionSymbol) bool {
    if peekType(context) {
      symbol.returnType = parseType(context)
    }
    if context.eat(.NEWLINE) && !context.peek(.LEFT_BRACE) {
      context.undo
    }
    return parseFunctionBlock(context, symbol)
  }

  def parseTypeParameters(context ParserContext, kind SymbolKind) List<ParameterSymbol> {
    var parameters List<ParameterSymbol> = []
    while true {
      var range = context.current.range
      var name = range.toString
      if !context.expect(.IDENTIFIER) {
        return null
      }
      var symbol = ParameterSymbol.new(kind, name)
      symbol.range = range
      parameters.append(symbol)
      if !context.eat(.COMMA) {
        break
      }
    }
    if !context.expect(.PARAMETER_LIST_END) {
      return null
    }
    return parameters
  }

  const identifierToSymbolKind StringMap<SymbolKind> = {
    "class": .OBJECT_CLASS,
    "def": .FUNCTION_GLOBAL,
    "enum": .OBJECT_ENUM,
    "flags": .OBJECT_ENUM,
    "interface": .OBJECT_INTERFACE,
    "namespace": .OBJECT_NAMESPACE,
    "over": .FUNCTION_GLOBAL,
    "type": .OBJECT_WRAPPED,
  }

  const customOperators = {
    TokenKind.ASSIGN_BITWISE_AND: 0,
    TokenKind.ASSIGN_BITWISE_OR: 0,
    TokenKind.ASSIGN_BITWISE_XOR: 0,
    TokenKind.ASSIGN_DIVIDE: 0,
    TokenKind.ASSIGN_INDEX: 0,
    TokenKind.ASSIGN_MINUS: 0,
    TokenKind.ASSIGN_MULTIPLY: 0,
    TokenKind.ASSIGN_PLUS: 0,
    TokenKind.ASSIGN_POWER: 0,
    TokenKind.ASSIGN_REMAINDER: 0,
    TokenKind.ASSIGN_SHIFT_LEFT: 0,
    TokenKind.ASSIGN_SHIFT_RIGHT: 0,
    TokenKind.ASSIGN_UNSIGNED_SHIFT_RIGHT: 0,
    TokenKind.BITWISE_AND: 0,
    TokenKind.BITWISE_OR: 0,
    TokenKind.BITWISE_XOR: 0,
    TokenKind.COMPARE: 0,
    TokenKind.DECREMENT: 0,
    TokenKind.DIVIDE: 0,
    TokenKind.IN: 0,
    TokenKind.INCREMENT: 0,
    TokenKind.INDEX: 0,
    TokenKind.LIST: 0,
    TokenKind.MINUS: 0,
    TokenKind.MULTIPLY: 0,
    TokenKind.NOT: 0,
    TokenKind.PLUS: 0,
    TokenKind.POWER: 0,
    TokenKind.REMAINDER: 0,
    TokenKind.SET: 0,
    TokenKind.SHIFT_LEFT: 0,
    TokenKind.SHIFT_RIGHT: 0,
    TokenKind.TILDE: 0,
    TokenKind.UNSIGNED_SHIFT_RIGHT: 0,
    TokenKind.XML_CHILD: 0,
  }

  enum ForbiddenGroup {
    ASSIGN
    COMPARE
    EQUAL
    LOGICAL
  }

  const forbiddenCustomOperators IntMap<ForbiddenGroup> = {
    TokenKind.ASSIGN: .ASSIGN,
    TokenKind.EQUAL: .EQUAL,
    TokenKind.GREATER_THAN: .COMPARE,
    TokenKind.GREATER_THAN_OR_EQUAL: .COMPARE,
    TokenKind.LESS_THAN: .COMPARE,
    TokenKind.LESS_THAN_OR_EQUAL: .COMPARE,
    TokenKind.LOGICAL_AND: .LOGICAL,
    TokenKind.LOGICAL_OR: .LOGICAL,
    TokenKind.NOT_EQUAL: .EQUAL,
  }

  # These are prefixed with "the operator \"...\" is not customizable because "
  const forbiddenGroupDescription = {
    ForbiddenGroup.ASSIGN: "value types are not supported by the language",
    ForbiddenGroup.COMPARE: "it's automatically implemented using the \"<=>\" operator (customize the \"<=>\" operator instead)",
    ForbiddenGroup.EQUAL: "that wouldn't work with generics, which are implemented with type erasure",
    ForbiddenGroup.LOGICAL: "of its special short-circuit evaluation behavior",
  }

  def parseAfterBlock(context ParserContext) bool {
    return context.peek(.END_OF_FILE) || context.peek(.RIGHT_BRACE) || context.expect(.NEWLINE)
  }

  const assignmentOperators IntMap<NodeKind> = {
    TokenKind.ASSIGN: .ASSIGN,
    TokenKind.ASSIGN_BITWISE_AND: .ASSIGN_BITWISE_AND,
    TokenKind.ASSIGN_BITWISE_OR: .ASSIGN_BITWISE_OR,
    TokenKind.ASSIGN_BITWISE_XOR: .ASSIGN_BITWISE_XOR,
    TokenKind.ASSIGN_DIVIDE: .ASSIGN_DIVIDE,
    TokenKind.ASSIGN_MINUS: .ASSIGN_SUBTRACT,
    TokenKind.ASSIGN_MULTIPLY: .ASSIGN_MULTIPLY,
    TokenKind.ASSIGN_PLUS: .ASSIGN_ADD,
    TokenKind.ASSIGN_POWER: .ASSIGN_POWER,
    TokenKind.ASSIGN_REMAINDER: .ASSIGN_REMAINDER,
    TokenKind.ASSIGN_SHIFT_LEFT: .ASSIGN_SHIFT_LEFT,
    TokenKind.ASSIGN_SHIFT_RIGHT: .ASSIGN_SHIFT_RIGHT,
    TokenKind.ASSIGN_UNSIGNED_SHIFT_RIGHT: .ASSIGN_UNSIGNED_SHIFT_RIGHT,
  }

  def recursiveParseGuard(context ParserContext, parent ObjectSymbol, annotations List<Node>) Guard {
    var test Node = null
    if context.eat(.IF) {
      test = expressionParser.parse(context, .LOWEST)
    }
    if !context.expect(.LEFT_BRACE) {
      return null
    }
    var contents = ObjectSymbol.new(parent.kind, "<conditional>")
    contents.flags |= .IS_GUARD_CONDITIONAL
    contents.parent = parent
    parseSymbols(context, contents, annotations)
    if !context.expect(.RIGHT_BRACE) || !context.peek(.ELSE) && !parseAfterBlock(context) {
      return null
    }
    var elseGuard Guard = null
    if context.eat(.ELSE) {
      elseGuard = recursiveParseGuard(context, parent, annotations)
      if elseGuard == null {
        return null
      }
    }
    return Guard.new(parent, test, contents, elseGuard)
  }

  def parseSymbol(context ParserContext, parent ObjectSymbol, annotations List<Node>) bool {
    # Parse comments before the symbol declaration
    var comments = parseLeadingComments(context)

    # Ignore trailing comments
    if context.peek(.RIGHT_BRACE) || context.peek(.END_OF_FILE) {
      return false
    }

    # Parse a compile-time if statement
    if context.peek(.IF) {
      var guard = recursiveParseGuard(context, parent, annotations)
      if guard == null {
        return false
      }
      parent.guards ?= []
      parent.guards.append(guard)
      return true
    }

    # Parse annotations before the symbol declaration
    if context.peek(.ANNOTATION) {
      annotations = parseAnnotations(context, annotations != null ? annotations.clone : [])
      if annotations == null {
        return false
      }

      # Parse an annotation block
      if context.eat(.LEFT_BRACE) {
        parseSymbols(context, parent, annotations)
        return context.expect(.RIGHT_BRACE) && parseAfterBlock(context)
      }
    }

    var token = context.current
    var text = token.range.toString
    var symbol Symbol = null

    # Special-case enum symbols
    if parent.kind == .OBJECT_ENUM && token.kind == .IDENTIFIER && !(text in identifierToSymbolKind) {
      var variable = VariableSymbol.new(.VARIABLE_ENUM, text)
      variable.range = token.range
      variable.parent = parent
      variable.flags |= .IS_CONST
      parent.variables.append(variable)
      symbol = variable
      context.next
    }

    else {
      # Parse the symbol kind
      var kind SymbolKind
      switch token.kind {
        case .CONST, .VAR {
          kind = parent.kind.hasInstances ? .VARIABLE_INSTANCE : .VARIABLE_GLOBAL
        }

        # For symbol kinds that can't live inside functions, use contextual
        # keywords instead of special keyword tokens. This means these names
        # are still available to be used as regular symbols:
        #
        #   class div {
        #     var class = ""
        #   }
        #
        #   var example = <div class="header"/>
        #
        case .IDENTIFIER {
          kind = identifierToSymbolKind.get(text, .OBJECT_GLOBAL)
          if kind == .OBJECT_GLOBAL {
            context.unexpectedToken
            return false
          }
          if kind == .FUNCTION_GLOBAL && parent.kind.hasInstances {
            kind = .FUNCTION_INSTANCE
          }
        }

        default {
          context.unexpectedToken
          return false
        }
      }
      context.next

      var nameToken = context.current
      var range = nameToken.range
      var name = range.toString
      var isOperator = false

      # Only check for custom operators for instance functions
      if kind == .FUNCTION_INSTANCE {
        if nameToken.kind in customOperators {
          isOperator = true
        } else if nameToken.kind in forbiddenCustomOperators {
          context.log.syntaxErrorBadOperatorCustomization(range, nameToken.kind,
            forbiddenGroupDescription[forbiddenCustomOperators[nameToken.kind]])
          isOperator = true
        }
      }

      # Parse the symbol name
      if isOperator {
        context.next
      } else if kind == .FUNCTION_GLOBAL && context.eat(.ANNOTATION) {
        kind = .FUNCTION_ANNOTATION
      } else if context.eat(.LIST_NEW) || context.eat(.SET_NEW) {
        if kind == .FUNCTION_INSTANCE {
          kind = .FUNCTION_CONSTRUCTOR
        }
      } else {
        if !context.expect(.IDENTIFIER) {
          return false
        }
        if kind == .FUNCTION_INSTANCE && name == "new" {
          kind = .FUNCTION_CONSTRUCTOR
        }
      }

      # Parse shorthand nested namespace declarations
      if kind.isObject {
        while context.eat(.DOT) {
          var nextToken = context.current
          if !context.expect(.IDENTIFIER) {
            return false
          }

          # Wrap this declaration in a namespace
          var nextParent = ObjectSymbol.new(.OBJECT_NAMESPACE, name)
          nextParent.range = range
          nextParent.parent = parent
          parent.objects.append(nextParent)
          parent = nextParent

          # Update the declaration token
          nameToken = nextToken
          range = nextToken.range
          name = range.toString
        }
      }

      # Parse the symbol body
      switch kind {
        case .VARIABLE_GLOBAL, .VARIABLE_INSTANCE {
          while true {
            var variable = VariableSymbol.new(kind, name)
            variable.range = range
            variable.parent = parent

            if token.kind == .CONST {
              variable.flags |= .IS_CONST
            }

            if peekType(context) {
              variable.type = parseType(context)
            }

            if context.eat(.ASSIGN) {
              variable.value = expressionParser.parse(context, .LOWEST)
              checkExtraParentheses(context, variable.value)
            }

            parent.variables.append(variable)

            if !context.eat(.COMMA) {
              symbol = variable
              break
            }

            variable.annotations = annotations?.clone
            variable.comments = comments

            nameToken = context.current
            range = nameToken.range
            name = range.toString

            if !context.expect(.IDENTIFIER) {
              return false
            }
          }
        }

        case .FUNCTION_ANNOTATION, .FUNCTION_CONSTRUCTOR, .FUNCTION_GLOBAL, .FUNCTION_INSTANCE {
          var function = FunctionSymbol.new(kind, name)
          function.range = range
          function.parent = parent

          if text == "over" {
            function.flags |= .IS_OVER
          }

          # Check for setters like "def foo=(x int) {}" but don't allow a space
          # between the name and the assignment operator
          if kind != .FUNCTION_ANNOTATION && nameToken.kind == .IDENTIFIER && context.peek(.ASSIGN) && context.current.range.start == nameToken.range.end {
            function.range = Range.span(function.range, context.next.range)
            function.flags |= .IS_SETTER
            function.name += "="
          }

          # Parse type parameters
          if context.eat(.PARAMETER_LIST_START) {
            function.parameters = parseTypeParameters(context, .PARAMETER_FUNCTION)
            if function.parameters == null {
              return false
            }
          }

          # Parse function arguments
          var before = context.current
          if context.eat(.LEFT_PARENTHESIS) {
            if !parseFunctionArguments(context, function) {
              return false
            }

            # Functions without arguments are "getters" and don't use parentheses
            if function.arguments.isEmpty {
              context.log.syntaxErrorEmptyFunctionParentheses(context.spanSince(before.range))
            }
          }

          if kind != .FUNCTION_ANNOTATION && !parseFunctionReturnTypeAndBlock(context, function) {
            return false
          }

          # Don't mark operators as getters to avoid confusion with unary operators and compiler-generated call expressions
          if !isOperator && function.arguments.isEmpty {
            function.flags |= .IS_GETTER
          }

          parent.functions.append(function)
          symbol = function
        }

        case .OBJECT_CLASS, .OBJECT_ENUM, .OBJECT_INTERFACE, .OBJECT_NAMESPACE, .OBJECT_WRAPPED {
          var object = ObjectSymbol.new(kind, name)
          object.range = range
          object.parent = parent

          if text == "flags" {
            object.flags |= .IS_FLAGS
          }

          if kind != .OBJECT_NAMESPACE && context.eat(.PARAMETER_LIST_START) {
            object.parameters = parseTypeParameters(context, .PARAMETER_OBJECT)
            if object.parameters == null {
              return false
            }
          }

          # Allow "type Foo = int"
          if kind == .OBJECT_WRAPPED && context.eat(.ASSIGN) {
            object.extends = parseType(context)
            if object.extends == null {
              return false
            }
          }

          # Regular block structure "type Foo : int {}"
          else {
            # Base class
            if context.eat(.COLON) {
              object.extends = parseType(context)
              if object.extends == null {
                return false
              }
            }

            # Interfaces
            if context.eat(.DOUBLE_COLON) {
              object.implements = []
              while true {
                var type = parseType(context)
                object.implements.append(type)
                if !context.eat(.COMMA) {
                  break
                }
              }
            }

            context.skipWhitespace
            if !context.expect(.LEFT_BRACE) {
              scanForToken(context, .LEFT_BRACE)
            }

            parseSymbols(context, object, null)

            if !context.expect(.RIGHT_BRACE) {
              return false
            }
          }

          parent.objects.append(object)
          symbol = object
        }

        default {
          assert(false)
        }
      }

      # Forbid certain kinds of symbols inside enums and wrapped types
      if (parent.kind == .OBJECT_ENUM || parent.kind == .OBJECT_WRAPPED || parent.kind == .OBJECT_INTERFACE) && (
          kind == .FUNCTION_CONSTRUCTOR || kind == .VARIABLE_INSTANCE) {
        context.log.syntaxErrorBadDeclarationInsideType(context.spanSince(token.range))
      }
    }

    symbol.annotations = annotations?.clone
    symbol.comments = comments

    comments = parseTrailingComment(context, comments)
    if comments != null {
      symbol.comments = comments
      context.eat(.NEWLINE)
    } else if !parseAfterBlock(context) {
      return false
    }

    return true
  }

  def parseSymbols(context ParserContext, parent ObjectSymbol, annotations List<Node>) {
    context.eat(.NEWLINE)

    while !context.peek(.END_OF_FILE) && !context.peek(.RIGHT_BRACE) {
      if !parseSymbol(context, parent, annotations) {
        break
      }
    }
  }

  def parseArgumentList(context ParserContext, parent Node, stop TokenKind) {
    var isFirst = true
    var hasNamedArguments = false

    context.skipWhitespace
    while !context.eat(stop) {
      if !isFirst && !context.expect(.COMMA) {
        scanForToken(context, stop)
        break
      }
      var value = expressionParser.parse(context, .LOWEST)

      if value.kind == .NAME && context.eat(.COLON) {
        var after = expressionParser.parse(context, .LOWEST)
        if after == null {
          scanForToken(context, stop)
          break
        }
        value = Node.createPair(value, after).withRange(context.spanSince(value.range))
        hasNamedArguments = true
      } else if hasNamedArguments {
        context.log.syntaxErrorUnnamedArgument(value.range)
      }

      parent.appendChild(value)
      context.skipWhitespace
      isFirst = false
    }
  }

  def parseHexCharacter(c int) int {
    if c >= '0' && c <= '9' { return c - '0' }
    if c >= 'A' && c <= 'F' { return c - 'A' + 10 }
    if c >= 'a' && c <= 'f' { return c - 'a' + 10 }
    return -1
  }

  def createStringNode(log Log, range Range) Node {
    return Node.createString(parseStringLiteral(log, range)).withRange(range)
  }

  def parseStringLiteral(log Log, range Range) string {
    var text = range.toString
    var count = text.count
    assert(count >= 2)
    assert(text[0] == '"' || text[0] == '\'' || text[0] == ')')
    assert(text[count - 1] == '"' || text[count - 1] == '\'' || text[count - 1] == '(')
    var builder = StringBuilder.new
    var start = 1
    var stop = count - (text[count - 1] == '(' ? 2 : 1)
    var i = start
    while i < stop {
      var c = text[i++]
      if c == '\\' {
        var escape = i - 1
        builder.append(text.slice(start, escape))
        if i < stop {
          c = text[i++]
          if c == 'n' {
            builder.append("\n")
            start = i
          }
          else if c == 'r' {
            builder.append("\r")
            start = i
          }
          else if c == 't' {
            builder.append("\t")
            start = i
          }
          else if c == '0' {
            builder.append("\0")
            start = i
          }
          else if c == '\\' || c == '"' || c == '\'' {
            builder.append(string.fromCodeUnit(c))
            start = i
          }
          else if c == 'x' {
            if i < stop {
              var c0 = parseHexCharacter(text[i++])
              if i < stop {
                var c1 = parseHexCharacter(text[i++])
                if c0 != -1 && c1 != -1 {
                  builder.append(string.fromCodeUnit(c0 << 4 | c1))
                  start = i
                }
              }
            }
          }
        }
        if start < i {
          log.syntaxErrorInvalidEscapeSequence(Range.new(range.source, range.start + escape, range.start + i))
        }
      }
    }
    builder.append(text.slice(start, i))
    return builder.toString
  }

  const intLiteral = (context ParserContext, token Token) Node => Node.createInt(parseIntLiteral(context.log, token.range).value).withRange(token.range)
  const stringLiteral = (context ParserContext, token Token) Node => createStringNode(context.log, token.range)

  def boolLiteral(value bool) fn(ParserContext, Token) Node {
    return (context, token) => Node.createBool(value).withRange(token.range)
  }

  def tokenLiteral(kind NodeKind) fn(ParserContext, Token) Node {
    return (context, token) => Node.new(kind).withRange(token.range)
  }

  def unaryPrefix(kind NodeKind) fn(ParserContext, Token, Node) Node {
    return (context, token, value) => Node.createUnary(kind, value).withRange(Range.span(token.range, value.range)).withInternalRange(token.range)
  }

  def unaryPostfix(kind NodeKind) fn(ParserContext, Node, Token) Node {
    return (context, value, token) => Node.createUnary(kind, value).withRange(Range.span(value.range, token.range)).withInternalRange(token.range)
  }

  def binaryInfix(kind NodeKind) fn(ParserContext, Node, Token, Node) Node {
    return (context, left, token, right) => {
      if kind == .ASSIGN && left.kind == .INDEX {
        left.appendChild(right)
        left.kind = .ASSIGN_INDEX
        return left.withRange(Range.span(left.range, right.range)).withInternalRange(Range.span(left.internalRange, right.range))
      }
      return Node.createBinary(kind, left, right).withRange(Range.span(left.range, right.range)).withInternalRange(token.range)
    }
  }

  var dotInfixParselet = (context ParserContext, left Node) Node => {
    context.next
    var range = context.current.range
    if !context.expect(.IDENTIFIER) {
      return context.createParseError
    }
    return Node.createDot(left, range.toString).withRange(context.spanSince(left.range)).withInternalRange(range)
  }

  var initializerParselet = (context ParserContext) Node => {
    var token = context.next
    var kind NodeKind = token.kind == .LEFT_BRACE ? .INITIALIZER_MAP : .INITIALIZER_LIST
    var node = Node.createInitializer(kind)

    if token.kind == .LEFT_BRACE || token.kind == .LEFT_BRACKET {
      var expectColon = kind != .INITIALIZER_LIST
      var end TokenKind = expectColon ? .RIGHT_BRACE : .RIGHT_BRACKET
      while true {
        context.eat(.NEWLINE)
        var comments = parseLeadingComments(context)
        if context.peek(end) {
          break
        }
        var first = expressionParser.parse(context, .LOWEST)
        var colon = context.current
        if !expectColon {
          node.appendChild(first)
        } else {
          if !context.expect(.COLON) {
            break
          }
          var second = expressionParser.parse(context, .LOWEST)
          first = Node.createPair(first, second).withRange(Range.span(first.range, second.range)).withInternalRange(colon.range)
          node.appendChild(first)
        }
        first.comments = comments
        if !context.eat(.COMMA) {
          break
        }
      }
      context.skipWhitespace
      scanForToken(context, end)
    } else if token.kind == .LIST_NEW || token.kind == .SET_NEW {
      node.appendChild(Node.createName("new").withRange(Range.new(token.range.source, token.range.start + 1, token.range.end - 1)))
    }
    return node.withRange(context.spanSince(token.range))
  }

  var parameterizedParselet = (context ParserContext, left Node) Node => {
    var value = Node.createParameterize(left)
    var token = context.next
    while true {
      var type = parseType(context)
      value.appendChild(type)
      if !context.eat(.COMMA) {
        break
      }
    }
    scanForToken(context, .PARAMETER_LIST_END)
    return value.withRange(context.spanSince(left.range)).withInternalRange(context.spanSince(token.range))
  }

  def createExpressionParser Pratt {
    var pratt = Pratt.new

    ########################################
    # Literals
    ########################################

    pratt.literal(.DOUBLE, (context, token) => Node.createDouble(parseDoubleLiteral(token.range.toString)).withRange(token.range))
    pratt.literal(.FALSE, boolLiteral(false))
    pratt.literal(.INT, intLiteral)
    pratt.literal(.INT_BINARY, intLiteral)
    pratt.literal(.INT_HEX, intLiteral)
    pratt.literal(.INT_OCTAL, intLiteral)
    pratt.literal(.NULL, tokenLiteral(.NULL))
    pratt.literal(.STRING, stringLiteral)
    pratt.literal(.SUPER, tokenLiteral(.SUPER))
    pratt.literal(.TRUE, boolLiteral(true))

    pratt.literal(.CHARACTER, (context, token) => {
      var result = parseStringLiteral(context.log, token.range)
      var codePoint = 0

      # There must be exactly one unicode code point
      var iterator = Unicode.StringIterator.INSTANCE.reset(result, 0)
      codePoint = iterator.nextCodePoint
      if codePoint == -1 || iterator.nextCodePoint != -1 {
        context.log.syntaxErrorInvalidCharacter(token.range)
      }

      # Don't return null when there's an error because that
      # error won't affect the rest of the compilation
      return Node.createInt(codePoint).withRange(token.range)
    })

    ########################################
    # Unary expressions
    ########################################

    pratt.prefix(.MINUS, .UNARY_PREFIX, unaryPrefix(.NEGATIVE))
    pratt.prefix(.NOT, .UNARY_PREFIX, unaryPrefix(.NOT))
    pratt.prefix(.PLUS, .UNARY_PREFIX, unaryPrefix(.POSITIVE))
    pratt.prefix(.TILDE, .UNARY_PREFIX, unaryPrefix(.COMPLEMENT))
    pratt.prefix(.INCREMENT, .UNARY_PREFIX, unaryPrefix(.PREFIX_INCREMENT))
    pratt.prefix(.DECREMENT, .UNARY_PREFIX, unaryPrefix(.PREFIX_DECREMENT))
    pratt.postfix(.INCREMENT, .UNARY_PREFIX, unaryPostfix(.POSTFIX_INCREMENT))
    pratt.postfix(.DECREMENT, .UNARY_PREFIX, unaryPostfix(.POSTFIX_DECREMENT))

    ########################################
    # Binary expressions
    ########################################

    pratt.infix(.BITWISE_AND, .BITWISE_AND, binaryInfix(.BITWISE_AND))
    pratt.infix(.BITWISE_OR, .BITWISE_OR, binaryInfix(.BITWISE_OR))
    pratt.infix(.BITWISE_XOR, .BITWISE_XOR, binaryInfix(.BITWISE_XOR))
    pratt.infix(.COMPARE, .COMPARE, binaryInfix(.COMPARE))
    pratt.infix(.DIVIDE, .MULTIPLY, binaryInfix(.DIVIDE))
    pratt.infix(.EQUAL, .EQUAL, binaryInfix(.EQUAL))
    pratt.infix(.GREATER_THAN, .COMPARE, binaryInfix(.GREATER_THAN))
    pratt.infix(.GREATER_THAN_OR_EQUAL, .COMPARE, binaryInfix(.GREATER_THAN_OR_EQUAL))
    pratt.infix(.IN, .COMPARE, binaryInfix(.IN))
    pratt.infix(.LESS_THAN, .COMPARE, binaryInfix(.LESS_THAN))
    pratt.infix(.LESS_THAN_OR_EQUAL, .COMPARE, binaryInfix(.LESS_THAN_OR_EQUAL))
    pratt.infix(.LOGICAL_AND, .LOGICAL_AND, binaryInfix(.LOGICAL_AND))
    pratt.infix(.LOGICAL_OR, .LOGICAL_OR, binaryInfix(.LOGICAL_OR))
    pratt.infix(.MINUS, .ADD, binaryInfix(.SUBTRACT))
    pratt.infix(.MULTIPLY, .MULTIPLY, binaryInfix(.MULTIPLY))
    pratt.infix(.NOT_EQUAL, .EQUAL, binaryInfix(.NOT_EQUAL))
    pratt.infix(.PLUS, .ADD, binaryInfix(.ADD))
    pratt.infix(.POWER, .UNARY_PREFIX, binaryInfix(.POWER))
    pratt.infix(.REMAINDER, .MULTIPLY, binaryInfix(.REMAINDER))
    pratt.infix(.SHIFT_LEFT, .SHIFT, binaryInfix(.SHIFT_LEFT))
    pratt.infix(.SHIFT_RIGHT, .SHIFT, binaryInfix(.SHIFT_RIGHT))
    pratt.infix(.UNSIGNED_SHIFT_RIGHT, .SHIFT, binaryInfix(.UNSIGNED_SHIFT_RIGHT))

    pratt.infixRight(.ASSIGN, .ASSIGN, binaryInfix(.ASSIGN))
    pratt.infixRight(.ASSIGN_BITWISE_AND, .ASSIGN, binaryInfix(.ASSIGN_BITWISE_AND))
    pratt.infixRight(.ASSIGN_BITWISE_OR, .ASSIGN, binaryInfix(.ASSIGN_BITWISE_OR))
    pratt.infixRight(.ASSIGN_BITWISE_XOR, .ASSIGN, binaryInfix(.ASSIGN_BITWISE_XOR))
    pratt.infixRight(.ASSIGN_DIVIDE, .ASSIGN, binaryInfix(.ASSIGN_DIVIDE))
    pratt.infixRight(.ASSIGN_MINUS, .ASSIGN, binaryInfix(.ASSIGN_SUBTRACT))
    pratt.infixRight(.ASSIGN_MULTIPLY, .ASSIGN, binaryInfix(.ASSIGN_MULTIPLY))
    pratt.infixRight(.ASSIGN_NULL, .ASSIGN, binaryInfix(.ASSIGN_NULL))
    pratt.infixRight(.ASSIGN_PLUS, .ASSIGN, binaryInfix(.ASSIGN_ADD))
    pratt.infixRight(.ASSIGN_POWER, .ASSIGN, binaryInfix(.ASSIGN_POWER))
    pratt.infixRight(.ASSIGN_REMAINDER, .ASSIGN, binaryInfix(.ASSIGN_REMAINDER))
    pratt.infixRight(.ASSIGN_SHIFT_LEFT, .ASSIGN, binaryInfix(.ASSIGN_SHIFT_LEFT))
    pratt.infixRight(.ASSIGN_SHIFT_RIGHT, .ASSIGN, binaryInfix(.ASSIGN_SHIFT_RIGHT))
    pratt.infixRight(.ASSIGN_UNSIGNED_SHIFT_RIGHT, .ASSIGN, binaryInfix(.ASSIGN_UNSIGNED_SHIFT_RIGHT))
    pratt.infixRight(.NULL_JOIN, .NULL_JOIN, binaryInfix(.NULL_JOIN))

    ########################################
    # Other expressions
    ########################################

    pratt.parselet(.DOT, .MEMBER).infix = dotInfixParselet
    pratt.parselet(.INDEX, .LOWEST).prefix = initializerParselet
    pratt.parselet(.LEFT_BRACE, .LOWEST).prefix = initializerParselet
    pratt.parselet(.LEFT_BRACKET, .LOWEST).prefix = initializerParselet
    pratt.parselet(.LIST_NEW, .LOWEST).prefix = initializerParselet
    pratt.parselet(.SET_NEW, .LOWEST).prefix = initializerParselet
    pratt.parselet(.PARAMETER_LIST_START, .MEMBER).infix = parameterizedParselet

    # String interpolation
    pratt.parselet(.STRING_INTERPOLATION_START, .LOWEST).prefix = (context) => {
      var token = context.next
      var node = Node.createStringInterpolation.appendChild(createStringNode(context.log, token.range))
      while true {
        var value = expressionParser.parse(context, .LOWEST)
        node.appendChild(value)
        context.skipWhitespace
        token = context.current
        if !context.eat(.STRING_INTERPOLATION_CONTINUE) && !context.expect(.STRING_INTERPOLATION_END) {
          return context.createParseError
        }
        node.appendChild(createStringNode(context.log, token.range))
        if token.kind == .STRING_INTERPOLATION_END {
          break
        }
      }
      return node.withRange(context.spanSince(node.firstChild.range))
    }

    # "x?.y"
    pratt.parselet(.NULL_DOT, .MEMBER).infix = (context, left) => {
      context.next
      var range = context.current.range
      if !context.expect(.IDENTIFIER) {
        return context.createParseError
      }
      return Node.createNullDot(left, range.toString).withRange(context.spanSince(left.range)).withInternalRange(range)
    }

    # Lambda expressions like "=> x"
    pratt.parselet(.ARROW, .LOWEST).prefix = (context) => {
      var token = context.current
      var symbol = FunctionSymbol.new(.FUNCTION_LOCAL, "<lambda>")
      if !parseFunctionBlock(context, symbol) {
        return context.createParseError
      }
      symbol.range = context.spanSince(token.range)
      return Node.createLambda(symbol).withRange(symbol.range)
    }

    # Cast expressions
    pratt.parselet(.AS, .UNARY_PREFIX).infix = (context, left) => {
      var token = context.next
      var type = parseType(context)
      return Node.createCast(left, type).withRange(context.spanSince(left.range)).withInternalRange(token.range)
    }

    # Using "." as a unary prefix operator accesses members off the inferred type
    pratt.parselet(.DOT, .MEMBER).prefix = (context) => {
      var token = context.next
      var range = context.current.range
      if !context.expect(.IDENTIFIER) {
        return context.createParseError
      }
      return Node.createDot(null, range.toString).withRange(context.spanSince(token.range)).withInternalRange(range)
    }

    # Access members off of "dynamic" for untyped globals
    pratt.parselet(.DYNAMIC, .LOWEST).prefix = (context) => {
      var token = context.next
      if !context.expect(.DOT) {
        return context.createParseError
      }
      var range = context.current.range
      if !context.expect(.IDENTIFIER) {
        return context.createParseError
      }
      return Node.createDot(Node.createType(.DYNAMIC), range.toString).withRange(context.spanSince(token.range)).withInternalRange(range)
    }

    # Name expressions and lambda expressions like "x => x * x"
    pratt.parselet(.IDENTIFIER, .LOWEST).prefix = (context) => {
      var range = context.next.range
      var name = range.toString
      if context.peek(.ARROW) {
        var symbol = FunctionSymbol.new(.FUNCTION_LOCAL, "<lambda>")
        var argument = VariableSymbol.new(.VARIABLE_ARGUMENT, name)
        argument.range = range
        symbol.arguments.append(argument)
        if !parseFunctionBlock(context, symbol) {
          return context.createParseError
        }
        symbol.range = context.spanSince(range)
        return Node.createLambda(symbol).withRange(symbol.range)
      }

      return Node.createName(name).withRange(range)
    }

    # Type check expressions
    pratt.parselet(.IS, .COMPARE).infix = (context, left) => {
      var token = context.next
      var type = parseType(context)
      return Node.createTypeCheck(left, type).withRange(context.spanSince(left.range)).withInternalRange(token.range)
    }

    # Index expressions
    pratt.parselet(.LEFT_BRACKET, .MEMBER).infix = (context, left) => {
      var token = context.next
      var right = expressionParser.parse(context, .LOWEST)
      scanForToken(context, .RIGHT_BRACKET)
      return Node.createIndex(left, right).withRange(context.spanSince(left.range)).withInternalRange(context.spanSince(token.range))
    }

    # Parenthetic groups and lambda expressions like "() => x"
    pratt.parselet(.LEFT_PARENTHESIS, .LOWEST).prefix = (context) => {
      var token = context.next

      # Try to parse a group
      if !context.peek(.RIGHT_PARENTHESIS) {
        var value = pratt.parse(context, .LOWEST)
        if (value.kind != .NAME || !peekType(context)) && context.eat(.RIGHT_PARENTHESIS) {
          if value.kind != .NAME || !context.peek(.ARROW) {
            return value.withRange(context.spanSince(token.range)).withFlags(.IS_INSIDE_PARENTHESES)
          }
          context.undo
        }
        context.undo
      }

      # Parse a lambda instead
      var symbol = FunctionSymbol.new(.FUNCTION_LOCAL, "<lambda>")
      if !parseFunctionArguments(context, symbol) || !parseFunctionReturnTypeAndBlock(context, symbol) {
        return context.createParseError
      }
      symbol.range = context.spanSince(token.range)
      return Node.createLambda(symbol).withRange(symbol.range)
    }

    # Call expressions
    pratt.parselet(.LEFT_PARENTHESIS, .UNARY_POSTFIX).infix = (context, left) => {
      var node = Node.createCall(left)
      var token = context.next
      parseArgumentList(context, node, .RIGHT_PARENTHESIS)
      return node.withRange(context.spanSince(left.range)).withInternalRange(context.spanSince(token.range))
    }

    # Hook expressions
    pratt.parselet(.QUESTION_MARK, .ASSIGN).infix = (context, left) => {
      context.next
      var middle = pratt.parse(context, (Precedence.ASSIGN - 1) as Precedence)
      if !context.expect(.COLON) {
        return context.createParseError
      }
      var right = pratt.parse(context, (Precedence.ASSIGN - 1) as Precedence)
      return Node.createHook(left, middle, right).withRange(context.spanSince(left.range))
    }

    # XML literals
    pratt.parselet(.XML_START, .LOWEST).prefix = (context) => {
      var token = context.next
      var tag = parseDotChain(context)
      if tag == null {
        scanForToken(context, .XML_END)
        return context.createParseError
      }
      var attributes = Node.createSequence

      # Parse attributes
      context.skipWhitespace
      while context.peek(.IDENTIFIER) {
        var name = parseDotChain(context)
        var assignment = context.current
        var kind = assignmentOperators.get(assignment.kind, .NULL)
        if kind == .NULL {
          context.expect(.ASSIGN)
          scanForToken(context, .XML_END)
          return context.createParseError
        }
        context.next
        var value = expressionParser.parse(context, (Precedence.UNARY_PREFIX - 1) as Precedence)
        attributes.appendChild(Node.createBinary(kind, name, value).withRange(context.spanSince(name.range)).withInternalRange(assignment.range))
        context.skipWhitespace
      }

      # Parse end of tag
      var block = Node.createBlock
      var closingTag Node = null
      context.skipWhitespace

      # Check for children
      if !context.eat(.XML_END_EMPTY) {
        if !context.expect(.XML_END) {
          scanForToken(context, .XML_END)
          return context.createParseError
        }

        # Parse children
        context.skipWhitespace
        if !parseStatements(context, block) || !context.expect(.XML_START_CLOSE) {
          return context.createParseError
        }
        block.withRange(context.spanSince(token.range))

        # Parse closing tag
        closingTag = parseDotChain(context)
        if closingTag == null {
          scanForToken(context, .XML_END)
          return context.createParseError
        }
        context.skipWhitespace
        if !context.expect(.XML_END) {
          scanForToken(context, .XML_END)
          return context.createParseError
        }

        # Validate closing tag (not a fatal error)
        if !tag.looksTheSameAs(closingTag) {
          context.log.syntaxErrorXMLClosingTagMismatch(closingTag.range, dotChainToString(closingTag), dotChainToString(tag), tag.range)
        }
      }

      return Node.createXML(tag, attributes, block, closingTag).withRange(context.spanSince(token.range))
    }

    return pratt
  }

  def dotChainToString(node Node) string {
    assert(node.kind == .NAME || node.kind == .DOT)
    if node.kind == .NAME { return node.asString }
    return dotChainToString(node.dotTarget) + "." + node.asString
  }

  def parseDotChain(context ParserContext) Node {
    var current = context.current
    if !context.expect(.IDENTIFIER) {
      return null
    }
    var chain = Node.createName(current.range.toString).withRange(current.range)
    while context.eat(.DOT) {
      current = context.current
      if !context.expect(.IDENTIFIER) {
        return null
      }
      chain = Node.createDot(chain, current.range.toString).withRange(context.spanSince(chain.range)).withInternalRange(current.range)
    }
    return chain
  }

  def createTypeParser Pratt {
    var pratt = Pratt.new

    pratt.literal(.DYNAMIC, (context, token) => Node.createType(.DYNAMIC).withRange(token.range))
    pratt.parselet(.DOT, .MEMBER).infix = dotInfixParselet
    pratt.parselet(.PARAMETER_LIST_START, .MEMBER).infix = parameterizedParselet

    # Name expressions or lambda type expressions like "fn(int) int"
    pratt.parselet(.IDENTIFIER, .LOWEST).prefix = (context) => {
      var node = Node.createLambdaType
      var returnType = node.lambdaReturnType
      var token = context.next
      var name = token.range.toString
      var isFirst = true

      if name != "fn" || !context.eat(.LEFT_PARENTHESIS) {
        return Node.createName(name).withRange(token.range)
      }

      # Parse argument types
      while !context.eat(.RIGHT_PARENTHESIS) {
        if !isFirst && !context.expect(.COMMA) {
          scanForToken(context, .RIGHT_PARENTHESIS)
          return context.createParseError
        }
        node.insertChildBefore(returnType, parseType(context))
        isFirst = false
      }

      # Parse return type if present
      if peekType(context) {
        returnType.replaceWith(parseType(context))
      }

      return node.withRange(context.spanSince(token.range))
    }

    return pratt
  }

  def parseFile(log Log, tokens List<Token>, global ObjectSymbol) {
    expressionParser ?= createExpressionParser
    typeParser ?= createTypeParser

    var context = ParserContext.new(log, tokens)
    parseSymbols(context, global, null)
    context.expect(.END_OF_FILE)
  }
}
